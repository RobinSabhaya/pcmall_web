# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${BLUE}[COMMIT-MSG]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Get the commit message file
COMMIT_MSG_FILE=$1

if [ ! -f "$COMMIT_MSG_FILE" ]; then
    print_error "Commit message file not found: $COMMIT_MSG_FILE"
    exit 1
fi

# Read the commit message
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

print_status "Validating commit message..."

# Skip validation for merge commits
if echo "$COMMIT_MSG" | grep -q "^Merge branch"; then
    print_status "Merge commit detected, skipping validation"
    exit 0
fi

# Skip validation for revert commits
if echo "$COMMIT_MSG" | grep -q "^Revert"; then
    print_status "Revert commit detected, skipping validation"
    exit 0
fi

# Skip validation for initial commit
if echo "$COMMIT_MSG" | grep -q "^Initial commit"; then
    print_status "Initial commit detected, skipping validation"
    exit 0
fi

# Check minimum length
if [ ${#COMMIT_MSG} -lt 10 ]; then
    print_error "Commit message too short (minimum 10 characters)"
    print_error "Current message: '$COMMIT_MSG'"
    exit 1
fi

# Check maximum length for subject line
SUBJECT_LINE=$(echo "$COMMIT_MSG" | head -n1)
if [ ${#SUBJECT_LINE} -gt 72 ]; then
    print_error "Subject line too long (maximum 72 characters)"
    print_error "Current length: ${#SUBJECT_LINE}"
    print_error "Subject: '$SUBJECT_LINE'"
    exit 1
fi

# Check conventional commits format
CONVENTIONAL_PATTERN="^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?: .+"

if ! echo "$SUBJECT_LINE" | grep -qE "$CONVENTIONAL_PATTERN"; then
    print_error "Commit message doesn't follow conventional commits format"
    print_error "Expected format: type(scope): description"
    print_error "Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build, revert"
    print_error "Example: 'feat(auth): add login functionality'"
    print_error "Current message: '$SUBJECT_LINE'"
    exit 1
fi

# Extract type and scope
COMMIT_TYPE=$(echo "$SUBJECT_LINE" | sed -n 's/^\([^(]*\).*/\1/p')
COMMIT_SCOPE=$(echo "$SUBJECT_LINE" | sed -n 's/^[^(]*(\([^)]*\)).*/\1/p')
COMMIT_DESCRIPTION=$(echo "$SUBJECT_LINE" | sed -n 's/^[^:]*: \(.*\)/\1/p')

# Validate commit type
case "$COMMIT_TYPE" in
    "feat")
        print_status "Feature commit detected" ;;
    "fix")
        print_status "Bug fix commit detected" ;;
    "docs")
        print_status "Documentation commit detected" ;;
    "style")
        print_status "Style/formatting commit detected" ;;
    "refactor")
        print_status "Refactoring commit detected" ;;
    "perf")
        print_status "Performance improvement commit detected" ;;
    "test")
        print_status "Test-related commit detected" ;;
    "chore")
        print_status "Maintenance commit detected" ;;
    "ci")
        print_status "CI/CD commit detected" ;;
    "build")
        print_status "Build system commit detected" ;;
    "revert")
        print_status "Revert commit detected" ;;
    *)
        print_error "Unknown commit type: $COMMIT_TYPE"
        exit 1 ;;
esac

# Check if description starts with lowercase (conventional commits)
FIRST_CHAR=$(echo "$COMMIT_DESCRIPTION" | cut -c1)
if echo "$FIRST_CHAR" | grep -q '[A-Z]'; then
    print_warning "Description should start with lowercase letter"
    print_warning "Current: '$COMMIT_DESCRIPTION'"
fi

# Check if description ends with period
if echo "$COMMIT_DESCRIPTION" | grep -q '\.$'; then
    print_warning "Description should not end with a period"
    print_warning "Current: '$COMMIT_DESCRIPTION'"
fi

# Check for imperative mood indicators
IMPERATIVE_INDICATORS=("add" "fix" "update" "remove" "implement" "create" "delete" "refactor" "improve")
DESCRIPTION_FIRST_WORD=$(echo "$COMMIT_DESCRIPTION" | awk '{print tolower($1)}')

IMPERATIVE_FOUND=false
for indicator in "${IMPERATIVE_INDICATORS[@]}"; do
    if [ "$DESCRIPTION_FIRST_WORD" = "$indicator" ]; then
        IMPERATIVE_FOUND=true
        break
    fi
done

if [ "$IMPERATIVE_FOUND" = false ]; then
    # Check for non-imperative indicators
    NON_IMPERATIVE=("added" "fixed" "updated" "removed" "implemented" "created" "deleted" "refactored" "improved")
    for indicator in "${NON_IMPERATIVE[@]}"; do
        if [ "$DESCRIPTION_FIRST_WORD" = "$indicator" ]; then
            print_warning "Consider using imperative mood: '$indicator' -> '${indicator%d}'"
            break
        fi
    done
fi

# Check for ticket/issue references
if echo "$COMMIT_MSG" | grep -qE "(#[0-9]+|JIRA-[0-9]+|closes|fixes|resolves)"; then
    print_status "Issue reference found in commit message"
fi

# Check for breaking changes
if echo "$COMMIT_MSG" | grep -qE "BREAKING CHANGE|!:"; then
    print_warning "Breaking change detected - ensure this is intentional"
fi

# Validate scope if present
if [ ! -z "$COMMIT_SCOPE" ]; then
    # Define allowed scopes for your project
    ALLOWED_SCOPES="api auth database config middleware routes tests utils docs ci deployment security performance all"
    
    SCOPE_VALID=false
    for scope in $ALLOWED_SCOPES; do
        if [ "$COMMIT_SCOPE" = "$scope" ]; then
            SCOPE_VALID=true
            break
        fi
    done
    
    if [ "$SCOPE_VALID" = false ]; then
        print_warning "Scope '$COMMIT_SCOPE' is not in the predefined list"
        print_warning "Allowed scopes: $ALLOWED_SCOPES"
        print_warning "Consider using one of the allowed scopes or updating the list"
    fi
fi

# Check for common typos and issues
COMMON_ISSUES=("teh" "adn" "nad" "taht" "seperate" "recieve" "occurence" "definately")
for issue in "${COMMON_ISSUES[@]}"; do
    if echo "$COMMIT_MSG" | grep -qi "$issue"; then
        print_warning "Possible typo detected: '$issue'"
    fi
done

# Check for placeholder text
PLACEHOLDER_PATTERNS=("TODO" "FIXME" "XXX" "placeholder" "test commit" "wip" "temp")
for pattern in "${PLACEHOLDER_PATTERNS[@]}"; do
    if echo "$COMMIT_MSG" | grep -qi "$pattern"; then
        print_warning "Placeholder text detected: '$pattern'"
        print_warning "Consider updating the commit message with meaningful description"
    fi
done

# Run commitlint if available
if command -v commitlint >/dev/null 2>&1; then
    print_status "Running commitlint validation..."
    echo "$COMMIT_MSG" | commitlint
    if [ $? -ne 0 ]; then
        print_error "commitlint validation failed"
        exit 1
    fi
fi

# Generate commit statistics
LINES_CHANGED=$(git diff --cached --numstat | awk '{inserted+=$1; deleted+=$2} END {print inserted+deleted}')
FILES_CHANGED=$(git diff --cached --name-only | wc -l)

if [ ! -z "$LINES_CHANGED" ] && [ "$LINES_CHANGED" -gt 0 ]; then
    print_status "Commit statistics: $FILES_CHANGED files, $LINES_CHANGED lines changed"
    
    # Warn about large commits
    if [ "$LINES_CHANGED" -gt 500 ]; then
        print_warning "Large commit detected ($LINES_CHANGED lines changed)"
        print_warning "Consider breaking this into smaller commits"
    fi
fi

print_success "Commit message validation passed! âœ…"
print_status "Message: '$SUBJECT_LINE'"